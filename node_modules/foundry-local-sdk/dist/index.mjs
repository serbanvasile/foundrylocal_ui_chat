import { FoundryLocalManager as FoundryLocalManager$1 } from './base.mjs';
export { DeviceType, ExecutionProvider } from './base.mjs';
import { execSync, exec } from 'child_process';

function assertFoundryAvailable() {
  try {
    if (process.platform === "win32") {
      execSync("where foundry");
    } else {
      execSync("which foundry");
    }
  } catch (error) {
    throw new Error("Foundry is not installed or not on PATH!");
  }
}
async function getServiceUrl() {
  try {
    const stdout = await new Promise((resolve, reject) => {
      exec("foundry service status", (err, stdout2) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(stdout2);
      });
    });
    const match = stdout.match(/http:\/\/(?:[a-zA-Z0-9.-]+|\d{1,3}(\.\d{1,3}){3}):\d+/);
    if (match) {
      return match[0];
    }
    return null;
  } catch (error) {
    console.error("Error getting service status:", error);
    return null;
  }
}
async function startService() {
  let serviceUrl = await getServiceUrl();
  if (serviceUrl !== null) {
    return serviceUrl;
  }
  exec("foundry service start", (err) => {
    if (err) {
      console.error("Error starting service:", err.message);
      return null;
    }
  });
  let retries = 10;
  while (retries > 0) {
    serviceUrl = await getServiceUrl();
    if (serviceUrl !== null) {
      return serviceUrl;
    }
    await new Promise((resolve) => setTimeout(resolve, 100));
    retries--;
  }
  console.warn("Foundry service did not start within the expected time. May not be running.");
  return null;
}

class FoundryLocalManager extends FoundryLocalManager$1 {
  /**
   * The service URL for the Foundry service.
   */
  _serviceUrl = null;
  /**
   * Constructs a new FoundryLocalManager instance
   * @param {Object} [options] - Optional configuration options for the FoundryLocalManager.
   * @param {Fetch} [options.fetch] - Optional custom fetch implementation to use for HTTP requests.
   * If not provided, the global fetch will be used.
   */
  constructor({ fetch: overriddenFetch = fetch } = {}) {
    assertFoundryAvailable();
    super({
      serviceUrl: "",
      fetch: overriddenFetch
    });
  }
  /**
   * Gets the service URL.
   * @throws {Error} If the service URL is not set.
   * @returns {string} The service URL.
   */
  get serviceUrl() {
    if (this._serviceUrl) {
      return this._serviceUrl;
    }
    throw new Error("Service URL is not set. Please start the service first.");
  }
  /**
   * Initializes the Foundry Local Manager with a model.
   * @param {string | null} aliasOrModelId - The alias or ID of the model to initialize with.
   * @param {DeviceType} [device] - Optional device type to filter models.
   * @returns {Promise<FoundryModelInfo | null>} The model information if initialized, otherwise null.
   */
  async init(aliasOrModelId, device) {
    await this.startService();
    if (aliasOrModelId) {
      await this.downloadModel(aliasOrModelId, device);
      const modelInfo = await this.loadModel(aliasOrModelId, device);
      return modelInfo;
    }
    return null;
  }
  /**
   * Checks if the Foundry service is running.
   * @returns {Promise<boolean>} True if the service is running, otherwise false.
   */
  async isServiceRunning() {
    this._serviceUrl = await getServiceUrl();
    return this._serviceUrl !== null;
  }
  /**
   * Starts the Foundry service.
   * @throws {Error} If the service fails to start.
   * @returns {Promise<void>} Resolves when the service is successfully started.
   */
  async startService() {
    this._serviceUrl = await startService();
    if (!this._serviceUrl) {
      throw new Error("Failed to start the service.");
    }
  }
}

export { FoundryLocalManager };
